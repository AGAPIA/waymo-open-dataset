import os
import tensorflow.compat.v1 as tf
import math
import numpy as np
import itertools
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import sys


tf.enable_eager_execution()
from waymo_open_dataset.utils import range_image_utils
from waymo_open_dataset.utils import transform_utils
from waymo_open_dataset.utils import  frame_utils
from waymo_open_dataset import dataset_pb2 as open_dataset

FILENAME = "/home/ciprian/Downloads/Waymo/segment-10023947602400723454_1120_000_1140_000_with_camera_labels.tfrecord" #'frames'

def get_min_max_3d_box_corners(boxes, frameTransform, name=None):
  """Given a set of upright boxes, return its 2 min and max corner points
     in world (global) space frame

  Args:
    boxes: tf Tensor [N, 7]. The inner dims are [center{x,y,z}, length, width,
      height, heading].
    name: the name scope.

  Returns:
    corners: tf Tensor [N, 3, 2].
  """
  with tf.compat.v1.name_scope(name, 'GetMinMax3dBoxCorners', [boxes]):
    center_x, center_y, center_z, length, width, height, heading = tf.unstack(
        boxes, axis=-1)

    # Step 1: get the box corners in local space
    # [N, 3, 3]
    rotation = transform_utils.get_yaw_rotation(heading)
    # [N, 3]
    translation = tf.stack([center_x, center_y, center_z], axis=-1)

    l2 = length * 0.5
    w2 = width * 0.5
    h2 = height * 0.5

    # [N, 2, 3]
    corners = tf.reshape(
        tf.stack([-l2, -w2, -h2, l2, w2, h2],axis=-1),
                            [-1, 2, 3])
    # [N, 2, 3]
    corners = tf.einsum('nij,nkj->nki', rotation, corners) + tf.expand_dims(translation, axis=-2)

    # Step 2: transform the box corners to world space

    #i.e.xmin, xmax | ymin, ymax | zmin, zmax
    carToWorldTransform = tf.convert_to_tensor(value=np.reshape(np.array(frameTransform).astype(np.float32), [1, 4, 4]))
    carToWorldRotation = carToWorldTransform[:, 0:3, 0:3]
    carToWorldTranslation = carToWorldTransform[:, 0:3, 3]
    corners = tf.einsum('nij,nkj->nki', carToWorldRotation, corners) + tf.expand_dims(carToWorldTranslation, axis=-2)

    return corners.numpy()

transform = np.eye(4)
bboxes = [[1.0,1.0,1.0, 10.0, 5.0, 3.0, 0.0], [2.0,2.0,2.0, 10.0, 5.0, 3.0, 0.0]]
corners = get_min_max_3d_box_corners(bboxes, transform)

# 1. Iterate over frame by frame of a segment
dataset = tf.data.TFRecordDataset(FILENAME, compression_type='')
lidarLabels = None

pedestrians_data = {}
vehicle_data = {}
for index, data in enumerate(dataset):
    # Read the frame in bytes
    frame = open_dataset.Frame()
    frame.ParseFromString(bytearray(data.numpy()))
    lidarLabels = frame.laser_labels

    print(f'There are {len(lidarLabels)} lidar labels')

    # Transform all boxes for this frame to the global world coordinates and retain minMax points from each
    allBoxes = [] * len(lidarLabels)
    for index, label in enumerate(lidarLabels):
        allBoxes[index] = label.box
    allBoxesMinMax = get_min_max_3d_box_corners(allBoxes, frame.pose.transform)
    assert allBoxesMinMax.shape[1] == 3 and allBoxesMinMax.shape[2] == 2, 'Incorrect format of data'

    # Write info for this frame
    if pedestrians_data.get(index) == None:
        pedestrians_data[index] = {}
    if vehicle_data.get(index) == None:
        vehicle_data[index] = {}

    for index, label in enumerate(lidarLabels):
        boxMinMax = allBoxesMinMax[index]

        isVehicle = label.type == label.TYPE_VEHICLE or label.type == label.TYPE_CYCLIST
        targetOutputDict = vehicle_data[index] if isVehicle else pedestrians_data[index]

        assert targetOutputDict.get(label.id) == None, "This entity Id is already in the set !!"
        targetOutputDict[label.id] = { "BBMinMax" : boxMinMax }

    break

print("Vehicles...", vehicle_data)
print("Pedestrians...", pedestrians_data)


'''
    print(label)
    print(label.type)
    if label.type == label.TYPE_VEHICLE or label.type == label.TYPE_CYCLIST:
        vehicle_labels.
    print(label.TYPE_VEHICLE )
'''